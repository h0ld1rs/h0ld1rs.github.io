<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>h0ld1rs的博客</title>
  
  <subtitle>浊眼之外，满目皆是狼藉</subtitle>
  <link href="https://h0ld1rs.github.io/atom.xml" rel="self"/>
  
  <link href="https://h0ld1rs.github.io/"/>
  <updated>2022-03-01T16:06:55.387Z</updated>
  <id>https://h0ld1rs.github.io/</id>
  
  <author>
    <name>h0ld1rs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go渗透测试笔记(三)</title>
    <link href="https://h0ld1rs.github.io/posts/32502.html"/>
    <id>https://h0ld1rs.github.io/posts/32502.html</id>
    <published>2022-03-01T13:39:42.000Z</published>
    <updated>2022-03-01T16:06:55.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go渗透测试笔记-三-—HTTP客户端与工具的远程交互"><a href="#Go渗透测试笔记-三-—HTTP客户端与工具的远程交互" class="headerlink" title="Go渗透测试笔记(三)—HTTP客户端与工具的远程交互"></a>Go渗透测试笔记(三)—HTTP客户端与工具的远程交互</h1><h2 id="0x00-Go的HTTP基础知识"><a href="#0x00-Go的HTTP基础知识" class="headerlink" title="0x00 Go的HTTP基础知识"></a>0x00 Go的HTTP基础知识</h2><ol><li>HTTP是一种无状态的协议，服务器不会维护每个请求的状态，而是通过多种方式跟踪其状态，这些方式可能包括：<code>会话标识符，cookie，HTTP标头等</code>。客户端和服务器有责任正确协商和验证状态</li><li>其次，客户端和服务器之间的通信可以一部或者同步进行，但他们需要以<code>请求/响应</code>的方式循环运行。可以在请求头中添加几个选项和表标头，以影响服务器的行为并创建可用的Web应用程序。最常见的是服务器托管Web浏览器渲染的文件，以生成数据的图形化，组织化和时尚化的表示形式。API通常使用<code>XML,JSON,MSGRPC</code>进行通信，某些情况下，可能检索到的是二进制格式，表示下载任意文件类型</li></ol><h2 id="0X01-调用HTTP-API"><a href="#0X01-调用HTTP-API" class="headerlink" title="0X01 调用HTTP API"></a>0X01 调用HTTP API</h2><h3 id="1-调用HTTP方法"><a href="#1-调用HTTP方法" class="headerlink" title="1. 调用HTTP方法"></a>1. 调用HTTP方法</h3><p>包使用<code>net/http</code></p><p>这些函数的使用格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get(url <span class="type">string</span>)(resp *Response,err <span class="type">error</span>)</span><br><span class="line">Head(url <span class="type">string</span>)(resp * Response,err <span class="type">error</span>)</span><br><span class="line">Post(url <span class="type">string</span>,bodyType <span class="type">string</span>,body io.Reader)(resp *Response.err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>每个函数都将URL字符串作为参数并将其用作请求的目的地。Post函数要比较复杂一些，Post()具有两个附加参数(bodyType 和io.Reader)，其中 bodyType()用于接受正文的<code>Content-Type</code>，HTTP标头，(通常为 application&#x2F;x-www-form-urlencoded)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r1,err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;无法调用&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r1.Body.Close()</span><br><span class="line">r2,err := http.Head(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">defer</span> r2.Body.Close()</span><br><span class="line">form := url.Values&#123;&#125;</span><br><span class="line">form.Add(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">r3,err := http.Post(</span><br><span class="line"><span class="string">&quot;http://www.goole.com&quot;</span>,</span><br><span class="line"><span class="string">&quot;application/x-www-form-urlencode&quot;</span>,</span><br><span class="line">strings.NewReader(form.Encode()),</span><br><span class="line">)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">defer</span> r3.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，Go又一个函数<code>PostForm()</code>可以代替</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r1,err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;无法调用&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r1.Body.Close()</span><br><span class="line">r2,err := http.Head(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">defer</span> r2.Body.Close()</span><br><span class="line">form := url.Values&#123;&#125;</span><br><span class="line">form.Add(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">r3,err := http.PostForm(<span class="string">&quot;http://www.baidu,com&quot;</span>,form)</span><br><span class="line"><span class="comment">//读取响应正文，未显示</span></span><br><span class="line"><span class="keyword">defer</span> r3.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的HTTP动词，如<code>PATCH,PUT,DELETE</code>，不存在便捷函数，我们主要使用这些动词来与<code>RESTFUL api</code>进行交互</p><h3 id="2-生成一个请求"><a href="#2-生成一个请求" class="headerlink" title="2. 生成一个请求"></a>2. 生成一个请求</h3><p>我们可以使用<code>NewRequest()</code>创建结构体 <code>Request</code>，然后使用Client的<code>Do()发送该结构体</code></p><p>结构如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> NewRequestWithContext(context.Background(), method, url, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要发送一个<code>DELETE</code>的请求，可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">req,err := http.NewRequest(<span class="string">&quot;DELETE&quot;</span>,<span class="string">&quot;http://www.baidu.com&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">resp,err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取响应内容并关闭</span></span><br><span class="line">resp.Body.Close()</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个<code>io.Reader</code>的<code>Put</code>请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">form := url.Values&#123;&#125;</span><br><span class="line">form.Add(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">req,err := http.NewRequest(</span><br><span class="line"><span class="string">&quot;PUT&quot;</span>,</span><br><span class="line"><span class="string">&quot;http://www.goole.com&quot;</span>,</span><br><span class="line">strings.NewReader(form.Encode()),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">resp,err := client.Do(req)</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-使用结构化进行解析"><a href="#3-使用结构化进行解析" class="headerlink" title="3. 使用结构化进行解析"></a>3. 使用结构化进行解析</h3><p>在发送请求后，我们需要<code>ioutil.ReadAll()</code>获取响应正文读取数据，进行一些错误检查，并将HTTP状态码和响应正文打印到<code>stdout</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">resp,err := http.Get(<span class="string">&quot;https://www.baidu.com/robots.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(resp.Status)</span><br><span class="line"><span class="comment">//读取并显示响应正文</span></span><br><span class="line">body,err :=ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收到<code>resp</code>的响应后，可以通过访问可输出的参数<code>Status</code>来检索状态字符串(例如200 OK)，还有一个与此类似的参数<code>StatusCode</code></p><p><code>Response</code>类型。该参数仅存状态字符串的整数部分</p><p><code>Response</code>类型包含一个可输出的参数<code>Body</code>，其类型为<code>io.ReadCloser</code>，<code>ioReadCloser</code>充当<code>io.Reader</code>以及<code>io.Closer</code>的接口，或者需要实现<code>Close()</code>函数以关闭reader并执行任何清理的接口。从<code>io.ReadCloser</code>读取数据后，需要在响应正文上调用<code>Close()</code>函数。使用<code>defer</code>关闭响应正文是一种常见的作法，这样可以保证函数在返回之前将其关闭</p><p>返回内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">User-agent: Baiduspider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: MSNBot</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Baiduspider-image</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: YoudaoBot</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou web spider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou inst spider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou spider2</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou blog</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou News Spider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sogou Orion spider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: ChinasoSpider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Sosospider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User-agent: yisouspider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: EasouSpider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /</span><br></pre></td></tr></table></figure><p>如果需要解析更多的结构化数据，如<code>JSON</code>格式的数据进行<code>API</code>交互，则可以使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">Status <span class="type">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">res,err := http.Post(</span><br><span class="line"><span class="string">&quot;http://IP:PORT/API&quot;</span>,</span><br><span class="line"><span class="string">&quot;application/json&quot;</span>,</span><br><span class="line"><span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> status Status</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;status);err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">log.Printf(<span class="string">&quot;%s-&gt;%s\n&quot;</span>,status.Status,status.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0X02-构建与Shodan交互的HTTP客户端"><a href="#0X02-构建与Shodan交互的HTTP客户端" class="headerlink" title="0X02 构建与Shodan交互的HTTP客户端"></a>0X02 构建与Shodan交互的HTTP客户端</h2><p>当一个泄露的错误消息的web应用会被列入低危险等级，但是，如果错误消息泄露了企业用户的格式，并且其VPN内使用了单因素身份认证，则这些消息可能会增加通过猜测密码攻击内部网络的可能性</p><p>以<code>Shodan</code>为例子,需要一个<code>Shodan</code>的<code>api密钥</code>。</p><p>从Shodan 站点获取 API 密钥并将其设为环境变量，仅当API密钥为<code>SHODAN_API_KEY</code>的时候，下面示例才能正常工作</p><p><code>SHODAN API</code>非常简单，可以生成良好的<code>JSON</code>响应，对初学者学习<code>API</code>交互很有帮助，以下是步骤</p><ol><li>查看服务的<code>API</code>文档</li><li>设计代码的逻辑结构，以减少代码的复杂性和复用性</li><li>根据需要在<code>Go</code> 中定义请求或者响应类型。</li><li>创建辅助函数或者类型以简化初始化，身份认证和通信，从而减少冗长或者复杂的逻辑</li><li>构建与<code>API</code>消费者函数和类型交互的客户端</li></ol><h3 id="1-清理API调用"><a href="#1-清理API调用" class="headerlink" title="1. 清理API调用"></a>1. 清理API调用</h3><p>在阅读<code>SHODAN</code>文档的时候，你应该已经注意到：每个公开的函数都需要发送<code>API密钥</code>，尽管这个值传递给你所创建的每个消费者函数，但这么操作会非常繁琐。硬编码处理基础<code>https://api.shodan.io</code>也会遇到相同的问题，如下面函数所示，要定义API函数，需要将令牌和URL一起传递给每个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">APIInfo</span><span class="params">(token, url <span class="type">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HostSearch</span><span class="params">(token, url <span class="type">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>因此，我们选择一种更为常用的方法，先创建一个<code>shodan.go</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Shodan</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BaseURL = <span class="string">&quot;http://api.shodan.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">apiKey <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(apikey <span class="type">string</span>)</span></span> *Client  &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Client&#123;apikey: apikey&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shodan URL 被定义为一个常见值，这样我们在实现函数中重用它，</p><p>由于这些是结构体<code>Client</code>上的方法，因此可以通过<code>s.apiKey</code>去检索<code>API</code>密钥，并且通过<code>BaseURL</code>去检索<code>URL</code></p><h3 id="2-查询Shodan-订阅情况"><a href="#2-查询Shodan-订阅情况" class="headerlink" title="2. 查询Shodan 订阅情况"></a>2. 查询Shodan 订阅情况</h3><p>现在，开始与<code>Shodan</code>进行互动，根据<code>API</code>文档，用于查询信息的调用如下</p><blockquote><p>shodan 文档：<a href="https://developer.shodan.io/api">https://developer.shodan.io/api</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.shodan.io/api-info?key=&#123;YOUR_API_KEY&#125;</span><br></pre></td></tr></table></figure><p>返回信息是如下的格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scan_credits&quot;</span><span class="punctuation">:</span> <span class="number">100000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;usage_limits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;scan_credits&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;query_credits&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;monitored_ips&quot;</span><span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stream-100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;https&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;unlocked&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;query_credits&quot;</span><span class="punctuation">:</span> <span class="number">100000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;monitored_ips&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;unlocked_left&quot;</span><span class="punctuation">:</span> <span class="number">100000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;telnet&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们首先需要在<code>api.go</code>中定义一个可用于把<code>json</code>响应解组为<code>go</code>结构体的类型，如果缺少这一步，将无法处理或者访问响应正文。</p><p>新建<code>api.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Shodan</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">QueryCredits <span class="type">int</span>    <span class="string">`json:&quot;query_credits&quot;`</span></span><br><span class="line">ScanCredits  <span class="type">int</span>    <span class="string">`json:&quot;scan_credits&quot;`</span></span><br><span class="line">Telnet       <span class="type">bool</span>   <span class="string">`json:&quot;telnet&quot;`</span></span><br><span class="line">Plan         <span class="type">string</span> <span class="string">`json:&quot;plan&quot;`</span></span><br><span class="line">Https        <span class="type">bool</span>   <span class="string">`json:&quot;https&quot;`</span></span><br><span class="line">Unlocked     <span class="type">bool</span>   <span class="string">`json:&quot;unlocked&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span>APIInfo()(*APIInfo, <span class="type">error</span>)  &#123;</span><br><span class="line">res,err := http.Get(fmt.Sprintf(<span class="string">&quot;%s/api-info?key=%s&quot;</span>,BaseURL,s.apikey))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ret  APIInfo;</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret);err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;ret,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用结构体数据显式调用<code>json</code>元素名称，以确保映射和解析数据</p><p>同时<code>APIInfo</code>发出HTTP的<code>Get</code>请求，，并将响应解码成<code>APIInfo</code>的结构体</p><p>我们在使用这段代码前，还需要使用一个有用的<code>API</code>调用(主机搜索)，将其添加到<code>host.go</code>文件中。</p><blockquote><p>根据API文档，该调用的请求和响应如下</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//api.shodan.io/shodan/host/search?key=&#123;YOUR_API_KEY&#125;&amp;query=&#123;query&#125;&amp;facets=&#123;facets&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">----有删减--------</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;matches&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;product&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">            <span class="string">&quot;hash&quot;</span>: <span class="number">-1609083510</span>,</span><br><span class="line">            <span class="string">&quot;ip&quot;</span>: <span class="number">1616761883</span>,</span><br><span class="line">            <span class="string">&quot;org&quot;</span>: <span class="string">&quot;Comcast Business&quot;</span>,</span><br><span class="line">            <span class="string">&quot;isp&quot;</span>: <span class="string">&quot;Comcast Business&quot;</span>,</span><br><span class="line">            <span class="string">&quot;transport&quot;</span>: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cpe&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;cpe:/a:igor_sysoev:nginx&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: <span class="string">&quot;HTTP/1.1 400 Bad Request\r\nServer: nginx\r\nDate: Mon, 25 Jan 2021 21:33:48 GMT\r\nContent-Type: text/html\r\nContent-Length: 650\r\nConnection: close\r\n\r\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;asn&quot;</span>: <span class="string">&quot;AS7922&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">443</span>,</span><br><span class="line">            <span class="string">&quot;hostnames&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;three.webapplify.net&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Denver&quot;</span>,</span><br><span class="line">                <span class="string">&quot;region_code&quot;</span>: <span class="string">&quot;CO&quot;</span>,</span><br><span class="line">                <span class="string">&quot;area_code&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;longitude&quot;</span>: <span class="number">-104.9078</span>,</span><br><span class="line">                <span class="string">&quot;country_code3&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;latitude&quot;</span>: <span class="number">39.7301</span>,</span><br><span class="line">                <span class="string">&quot;postal_code&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;dma_code&quot;</span>: <span class="number">751</span>,</span><br><span class="line">                <span class="string">&quot;country_code&quot;</span>: <span class="string">&quot;US&quot;</span>,</span><br><span class="line">                <span class="string">&quot;country_name&quot;</span>: <span class="string">&quot;United States&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2021-01-25T21:33:49.154513&quot;</span>,</span><br><span class="line">            <span class="string">&quot;domains&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;webapplify.net&quot;</span></span><br><span class="line">            ],</span><br><span class="line">         </span><br><span class="line">            <span class="string">&quot;http&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;robots_hash&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;redirects&quot;</span>: [],</span><br><span class="line">                <span class="string">&quot;securitytxt&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: <span class="string">&quot;410 Gone&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sitemap_hash&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;robots&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;server&quot;</span>: <span class="string">&quot;nginx/1.4.2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;host&quot;</span>: <span class="string">&quot;185.11.246.51&quot;</span>,</span><br><span class="line">                <span class="string">&quot;html&quot;</span>: <span class="string">&quot;\n\n410 Gone\n\nGone\nThe requested resource/\nis no longer available on this server and there is no forwarding address.\nPlease remove all references to this resource.\n\n&quot;</span>,</span><br><span class="line">                <span class="string">&quot;location&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;components&quot;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&quot;securitytxt_hash&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;sitemap&quot;</span>: null,</span><br><span class="line">                <span class="string">&quot;html_hash&quot;</span>: <span class="number">922034037</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;_shodan&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;crawler&quot;</span>: <span class="string">&quot;c9b639b99e5410a46f656e1508a68f1e6e5d6f99&quot;</span>,</span><br><span class="line">                <span class="string">&quot;ptr&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;118b7360-01d0-4edb-8ee9-01e411c23e60&quot;</span>,</span><br><span class="line">                <span class="string">&quot;module&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">                <span class="string">&quot;options&quot;</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;ip_str&quot;</span>: <span class="string">&quot;185.11.246.51&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;facets&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;country&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="string">&quot;count&quot;</span>: <span class="number">1717359</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;HK&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;count&quot;</span>: <span class="number">940900</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;FR&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: <span class="number">23047224</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的代码是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Shodan</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HostLocation <span class="keyword">struct</span> &#123;</span><br><span class="line">City         <span class="type">string</span>  <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">RegionCode   <span class="type">string</span>  <span class="string">`json:&quot;region_code&quot;`</span></span><br><span class="line">AreaCode     <span class="type">int</span>     <span class="string">`json:&quot;area_code&quot;`</span></span><br><span class="line">Longitude    <span class="type">float32</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">CountryCode3 <span class="type">string</span>  <span class="string">`json:&quot;country_code3&quot;`</span></span><br><span class="line">CountryName  <span class="type">string</span>  <span class="string">`json:&quot;country_name&quot;`</span></span><br><span class="line">PostalCode   <span class="type">string</span>  <span class="string">`json:&quot;postal_code&quot;`</span></span><br><span class="line">DMACode      <span class="type">int</span>     <span class="string">`json:&quot;dma_code&quot;`</span></span><br><span class="line">CountryCode  <span class="type">string</span>  <span class="string">`json:&quot;country_code&quot;`</span></span><br><span class="line">Latitude     <span class="type">float32</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Host <span class="keyword">struct</span> &#123;</span><br><span class="line">OS        <span class="type">string</span>       <span class="string">`json:&quot;os&quot;`</span></span><br><span class="line">Timestamp <span class="type">string</span>       <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">ISP       <span class="type">string</span>       <span class="string">`json:&quot;isp&quot;`</span></span><br><span class="line">ASN       <span class="type">string</span>       <span class="string">`json:&quot;asn&quot;`</span></span><br><span class="line">Hostnames []<span class="type">string</span>     <span class="string">`json:&quot;hostnames&quot;`</span></span><br><span class="line">Location  HostLocation <span class="string">`json:&quot;location&quot;`</span></span><br><span class="line">IP        <span class="type">int64</span>        <span class="string">`json:&quot;ip&quot;`</span></span><br><span class="line">Domains   []<span class="type">string</span>     <span class="string">`json:&quot;domains&quot;`</span></span><br><span class="line">Org       <span class="type">string</span>       <span class="string">`json:&quot;org&quot;`</span></span><br><span class="line">Data      <span class="type">string</span>       <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">Port      <span class="type">int</span>          <span class="string">`json:&quot;port&quot;`</span></span><br><span class="line">IPString  <span class="type">string</span>       <span class="string">`json:&quot;ip_str&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HostSearch <span class="keyword">struct</span> &#123;</span><br><span class="line">Matches []Host <span class="string">`json:&quot;matches&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Client)</span></span> HostSearch(q <span class="type">string</span>) (*HostSearch, <span class="type">error</span>) &#123;</span><br><span class="line">res, err := http.Get(</span><br><span class="line">fmt.Sprintf(<span class="string">&quot;%s/shodan/host/search?key=%s&amp;query=%s&quot;</span>, BaseURL, s.apiKey, q),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret HostSearch</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;ret); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>HostSearch：用于解析<code>matches</code>数组</li><li>Host：表示matches的一个元素</li><li>HostLocation：表示主机中的<code>location</code>字段</li></ul><p>接下来，我们创建main函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;Test1/Shodan&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Usage: main &lt;searchterm&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">apiKey := os.Getenv(<span class="string">&quot;SHODAN_API_KEY&quot;</span>)</span><br><span class="line">s := Shodan.New(apiKey)</span><br><span class="line">info, err := s.APIInfo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(</span><br><span class="line"><span class="string">&quot;Query Credits: %d\nScan Credits:  %d\n\n&quot;</span>,</span><br><span class="line">info.QueryCredits,</span><br><span class="line">info.ScanCredits)</span><br><span class="line"></span><br><span class="line">hostSearch, err := s.HostSearch(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, host := <span class="keyword">range</span> hostSearch.Matches &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%18s%8d\n&quot;</span>, host.IPString, host.Port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们输入<code>go run main.go Tomcat</code>的时候，便可以查询</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301213245.png"></p><p>OK，一个调用<code>Shodan API</code>的小型 go程序就完成了</p><h2 id="0x03-与Metasploit交互"><a href="#0x03-与Metasploit交互" class="headerlink" title="0x03 与Metasploit交互"></a>0x03 与Metasploit交互</h2><p>msf 想必都熟悉，在这里，我们将会构建一个与远程<code>Metasploit</code>实例进行交互的客户端，他要比<code>Shodan</code>更复杂</p><p>书上让本地启动 <code>msfconsole</code>和 <code>msgrpc</code>，这里，我选择使用<code>kali</code>进行替代</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301220321.png"></p><p>书上说为了保险，避免对一些值进行硬编码，需要将以下值设置到环境变量中去，但是这里为了方便，我就先不设置了。</p><p><code>export MSFHOST xxxxxxxx</code></p><p><code>export MSFPASS xxxxxx</code></p><p>现在如图上方，我们已经运行了<code>MSF 和 RPC</code>的服务器，接下来，我们查看<code>MSF API</code>的开发文档，发现，他与使用<code>JSON</code>交互的<code>Shodan</code>不同，msf使用了<code>MessagePack</code>（一种紧凑而高效的二进制格式）进行通信。但是，由于 go 官方库中不含，所以我们需要下载它</p><p><code> go get gopkg.in/vmihailenco/msgpack.v2</code></p><h3 id="1-定义目标"><a href="#1-定义目标" class="headerlink" title="1. 定义目标"></a>1. 定义目标</h3><p>现在定义一个RPC包，创建<code>msf.go</code>，</p><p>在<code>Metasploit</code>开发人员文档中的方法<code>session.list</code></p><blockquote><p>官方文档：<a href="https://docs.rapid7.com/metasploit/rpc-api/">https://docs.rapid7.com/metasploit/rpc-api/</a></p><p><a href="https://docs.rapid7.com/metasploit/standard-api-methods-reference/">https://docs.rapid7.com/metasploit/standard-api-methods-reference/</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="string">&quot;session.list&quot;</span><span class="punctuation">,</span> <span class="string">&quot;token&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这是最小的目标，它期望接收实现的方法是<code>名称和令牌</code>，<code>token</code>值是一个占位符，由文档可知，这是一个身份认证的令牌，是成功登录<code>RPC</code>服务器发出的，从<code>Metasploit</code>返回的方法<code>session.list</code>响应采用以下格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span> =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;type&#x27; =&gt; <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;tunnel_local&quot;</span> =&gt; <span class="string">&quot;192.168.35.149:44444&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;tunnel_peer&quot;</span> =&gt; <span class="string">&quot;192.168.35.149:43886&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;via_exploit&quot;</span> =&gt; <span class="string">&quot;exploit/multi/handler&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;via_payload&quot;</span> =&gt; <span class="string">&quot;payload/windows/shell_reverse_tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;desc&quot;</span> =&gt; <span class="string">&quot;Command shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;info&quot;</span> =&gt; <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;workspace&quot;</span> =&gt; <span class="string">&quot;Project1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;target_host&quot;</span> =&gt; <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;username&quot;</span> =&gt; <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;uuid&quot;</span> =&gt; <span class="string">&quot;hjahs9kw&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;exploit_uuid&quot;</span> =&gt; <span class="string">&quot;gcprpj2a&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;routes&quot;</span> =&gt; <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301224456.png"></p><p>该响应作为映射返回，<code>Meterpreter</code>会话标识符是关键，而会话的详细信息是值</p><p>现在需要构建 <code>Go</code>数据类型和响应结构体，根据文档，</p><p>请求结构体<code>sessionListReq</code>按照<code>Metasploit RPC</code>服务器所接受的方式，将结构化数据，序列化为<code>MessagePack</code>格式，数据以数组的而不是映射的形式传递，因此，<code>RPC</code>希望接受到的是作为值的<code>位置数组</code>。&#x3D;&#x3D;默认情况下，结构体将被编码为包含从属性名称推导出来的键名映射。&#x3D;&#x3D;要禁用此功能且将其强制将其编码为<code>位置数组</code>，必须添加一个名为<code>_msgpack</code>的特殊字段，该字段利用描述符<code>asArray</code>，显示指示编码器&#x2F;解码器将数据视为数组</p><p>响应结构体<code>SessionListRes</code>包含响应字段和结构体属性的一一对应关系，该数据本质上是一个请按套映射，外层映射是会话详细信息的会话标识符，内层映射是内层会话的详细信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sessionListReq <span class="keyword">struct</span> &#123;</span><br><span class="line">_msgpack <span class="keyword">struct</span>&#123;&#125; <span class="string">`msgpack:&quot;,asArray&quot;`</span></span><br><span class="line">Method   <span class="type">string</span></span><br><span class="line">Token    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SessionListRes <span class="keyword">struct</span> &#123;</span><br><span class="line">ID          <span class="type">uint32</span> <span class="string">`msgpack:&quot;,omitempty&quot;`</span></span><br><span class="line">Type        <span class="type">string</span> <span class="string">`msgpack:&quot;type&quot;`</span></span><br><span class="line">TunnelLocal <span class="type">string</span> <span class="string">`msgpack:&quot;tunnel_local&quot;`</span></span><br><span class="line">TunnelPeer  <span class="type">string</span> <span class="string">`msgpack:&quot;tunnel_peer&quot;`</span></span><br><span class="line">ViaExploit  <span class="type">string</span> <span class="string">`msgpack:&quot;via_exploit&quot;`</span></span><br><span class="line">ViaPayload  <span class="type">string</span> <span class="string">`msgpack:&quot;via_payload&quot;`</span></span><br><span class="line">Description <span class="type">string</span> <span class="string">`msgpack:&quot;desc&quot;`</span></span><br><span class="line">Info        <span class="type">string</span> <span class="string">`msgpack:&quot;info&quot;`</span></span><br><span class="line">Workspace   <span class="type">string</span> <span class="string">`msgpack:&quot;workspace&quot;`</span></span><br><span class="line">SessionHost <span class="type">string</span> <span class="string">`msgpack:&quot;session_host&quot;`</span></span><br><span class="line">SessionPort <span class="type">int</span>    <span class="string">`msgpack:&quot;session_port&quot;`</span></span><br><span class="line">Username    <span class="type">string</span> <span class="string">`msgpack:&quot;username&quot;`</span></span><br><span class="line">UUID        <span class="type">string</span> <span class="string">`msgpack:&quot;uuid&quot;`</span></span><br><span class="line">ExploitUUID <span class="type">string</span> <span class="string">`msgpack:&quot;exploit_uuid&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取有效令牌"><a href="#2-获取有效令牌" class="headerlink" title="2. 获取有效令牌"></a>2. 获取有效令牌</h3><p>现在，我们需要获取一个有效的登录令牌来获取请求，为此，我们将为api方法<code>auth.login()</code>发出一个登录请求，该请求满足以下条件</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301231549.png"></p><p>登录失败的话</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301231713.png"></p><p>还有登出令牌的功能</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301231814.png"></p><h3 id="3-定义请求和响应"><a href="#3-定义请求和响应" class="headerlink" title="3. 定义请求和响应"></a>3. 定义请求和响应</h3><p><code>suth.login</code>和<code>auth.logout</code>同理，我们需要使用描述控制符将请求序列化为数组并将响应视为映射</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> logoutReq <span class="keyword">struct</span> &#123;</span><br><span class="line">_msgpack    <span class="keyword">struct</span>&#123;&#125; <span class="string">`msgpack:&quot;,asArray&quot;`</span></span><br><span class="line">Method      <span class="type">string</span></span><br><span class="line">Token       <span class="type">string</span></span><br><span class="line">LogoutToken <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> logoutRes <span class="keyword">struct</span> &#123;</span><br><span class="line">Result <span class="type">string</span> <span class="string">`msgpack:&quot;result&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loginReq <span class="keyword">struct</span> &#123;</span><br><span class="line">_msgpack <span class="keyword">struct</span>&#123;&#125; <span class="string">`msgpack:&quot;,asArray&quot;`</span></span><br><span class="line">Method   <span class="type">string</span></span><br><span class="line">Username <span class="type">string</span></span><br><span class="line">Password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loginRes <span class="keyword">struct</span> &#123;</span><br><span class="line">Result       <span class="type">string</span> <span class="string">`msgpack:&quot;result&quot;`</span></span><br><span class="line">Token        <span class="type">string</span> <span class="string">`msgpack:&quot;token&quot;`</span></span><br><span class="line">Error        <span class="type">bool</span>   <span class="string">`msgpack:&quot;error&quot;`</span></span><br><span class="line">ErrorClass   <span class="type">string</span> <span class="string">`msgpack:&quot;error_class&quot;`</span></span><br><span class="line">ErrorMessage <span class="type">string</span> <span class="string">`msgpack:&quot;error_message&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go可以自动的对登录响应进行序列化，仅填充了存在的字段，这意味着我们可以使用单一结构式表示成功或者失败</p><h3 id="4-创建配置结构体和RPC方法"><a href="#4-创建配置结构体和RPC方法" class="headerlink" title="4. 创建配置结构体和RPC方法"></a>4. 创建配置结构体和RPC方法</h3><p>创建一个结构体类型，以供数据隐式引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Metasploit <span class="keyword">struct</span> &#123;</span><br><span class="line">host  <span class="type">string</span></span><br><span class="line">user  <span class="type">string</span></span><br><span class="line">pass  <span class="type">string</span></span><br><span class="line">token <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host, user, pass <span class="type">string</span>)</span></span> *Metasploit &#123;</span><br><span class="line">msf := &amp;Metasploit&#123;</span><br><span class="line">host: host,</span><br><span class="line">user: user,</span><br><span class="line">pass: pass,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-执行远程调用"><a href="#5-执行远程调用" class="headerlink" title="5. 执行远程调用"></a>5. 执行远程调用</h3><p>构建一个方法，执行远程调用。为了防止大量的代码重复，先构建一个可以执行，序列化，反序列化和HTTP通信逻辑的方法 send()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msf *Metasploit)</span></span> send(req <span class="keyword">interface</span>&#123;&#125;, res <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">msgpack.NewEncoder(buf).Encode(req)</span><br><span class="line">dest := fmt.Sprintf(<span class="string">&quot;http://%s/api&quot;</span>, msf.host)</span><br><span class="line">r, err := http.Post(dest, <span class="string">&quot;binary/message-pack&quot;</span>, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := msgpack.NewDecoder(r.Body).Decode(&amp;res); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>send</code>方法中，接受interface{}类型的请求和响应参数。使用此接口类型，可以将任何请求结构体传递到方法中，然后序列化发送到服务器，无需使用显示返回响应的方法。</p><p>接下来，使用<code>msgPack</code>库对请求进行<code>URL</code>编码，可以按照处理其他标准结构化数据的数据逻辑：首先通过NewEncoder()创建编码器，然后调用<code>Encode</code>方法，这将用<code>MessagePack</code>编码表示的请求体填充buf变量。之后发出POST请求，将主题设置为序列化数据。</p><p>然后接下来定义三个方法，每个方法使用相同的常规流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msf *Metasploit)</span></span> Login() <span class="type">error</span> &#123;</span><br><span class="line">ctx := &amp;loginReq&#123;</span><br><span class="line">Method:   <span class="string">&quot;auth.login&quot;</span>,</span><br><span class="line">Username: msf.user,</span><br><span class="line">Password: msf.pass,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res loginRes</span><br><span class="line"><span class="keyword">if</span> err := msf.send(ctx, &amp;res); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">msf.token = res.Token</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msf *Metasploit)</span></span> Logout() <span class="type">error</span> &#123;</span><br><span class="line">ctx := &amp;logoutReq&#123;</span><br><span class="line">Method:      <span class="string">&quot;auth.logout&quot;</span>,</span><br><span class="line">Token:       msf.token,</span><br><span class="line">LogoutToken: msf.token,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res logoutRes</span><br><span class="line"><span class="keyword">if</span> err := msf.send(ctx, &amp;res); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">msf.token = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msf *Metasploit)</span></span> SessionList() (<span class="keyword">map</span>[<span class="type">uint32</span>]SessionListRes, <span class="type">error</span>) &#123;</span><br><span class="line">req := &amp;sessionListReq&#123;Method: <span class="string">&quot;session.list&quot;</span>, Token: msf.token&#125;</span><br><span class="line">res := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint32</span>]SessionListRes)</span><br><span class="line"><span class="keyword">if</span> err := msf.send(req, &amp;res); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id, session := <span class="keyword">range</span> res &#123;</span><br><span class="line">session.ID = id</span><br><span class="line">res[id] = session</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>RPC</code>函数 session.list()需要有效的身份令牌，这就意味着必须要先登录，但是才能掉用方法<code>SessionList()</code></p><p>所以可以对<code>New</code>函数做一个更改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(host, user, pass <span class="type">string</span>)</span></span> (*Metasploit,<span class="type">error</span>)&#123;</span><br><span class="line">msf := &amp;Metasploit&#123;</span><br><span class="line">host: host,</span><br><span class="line">user: user,</span><br><span class="line">pass: pass,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := msf.Login(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msf,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-执行"><a href="#6-执行" class="headerlink" title="6.执行"></a>6.执行</h3><p>创建 <code>clinet/main.go</code>文件</p><p>这里没用获取环境变量，原文是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host := os.Getenv(<span class="string">&quot;MSFHOST&quot;</span>)</span><br><span class="line">pass := os.Getenv(<span class="string">&quot;MSFPASS&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里输入自己的数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;MSF/rpc&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">host := <span class="string">&quot;&quot;</span></span><br><span class="line">pass := <span class="string">&quot;&quot;</span></span><br><span class="line">user := <span class="string">&quot;msf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> || pass == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;Missing required environment variable MSFHOST or MSFPASS&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msf, err := rpc.New(host, user, pass)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> msf.Logout()</span><br><span class="line"></span><br><span class="line">sessions, err := msf.SessionList()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Sessions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, session := <span class="keyword">range</span> sessions &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5d  %s\n&quot;</span>, session.ID, session.Info)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220302000546.png"></p><p>如果有<code>Meterpreter</code>会话则会保存下来</p>]]></content>
    
    
    <summary type="html">对Go渗透测试中的一些学习</summary>
    
    
    
    <category term="Go渗透测试" scheme="https://h0ld1rs.github.io/categories/Go%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Golang,渗透测试" scheme="https://h0ld1rs.github.io/tags/Golang-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://h0ld1rs.github.io/posts/26832.html"/>
    <id>https://h0ld1rs.github.io/posts/26832.html</id>
    <published>2022-03-01T10:46:08.000Z</published>
    <updated>2022-03-01T10:47:54.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="懒人搭建博客"><a href="#懒人搭建博客" class="headerlink" title="懒人搭建博客"></a>懒人搭建博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想重启博客这个东西，发一些自己写的笔记啥的，由于重装系统之后之前的东西都不见了，所以，，还得重新来一下(xdm，一定要做好备份啊，不要憨憨的不备份重装系统)</p><p>搭建其实还是使用最简单的<code>hexo + butterfly</code>搭建的，没有什么难点，主要是遇到了一个在<code>butterfly</code>主题修改<code>_config.yml</code>的时候，有一个背景图片始终无法加载成功，但是在本地预览的时候是可以正常访问的，在<code>hexo d</code>后则是不能访问，在把<code>public</code>文件夹放置公网后发现，发现应该是<code>nodejs</code>版本的问题，最后解决成功了，，(菜鸡花了两天时间)</p><p>这里就放一下用到的命令和对应的版本吧</p><blockquote><p>#需要安装的东西<br>npm install –save hexo-deployer-git<br>npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</p><p>#主题</p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;Butterfly</p><p>#环境</p><p>npm 8.3.1<br>node v16.14.0<br>hexo-cli: 4.3.0<br>os: win32 10.0.22000<br>node: 16.14.0<br>v8: 9.4.146.24-node.20<br>uv: 1.43.0<br>zlib: 1.2.11<br>brotli: 1.0.9<br>ares: 1.18.1<br>modules: 93<br>nghttp2: 1.45.1<br>napi: 8<br>llhttp: 6.0.4<br>openssl: 1.1.1m+quic<br>cldr: 40.0<br>icu: 70.1<br>tz: 2021a3<br>unicode: 14.0<br>ngtcp2: 0.1.0-DEV<br>nghttp3: 0.1.0-DEV</p></blockquote><p>新手搭建博客请看：<a href="https://yafine-blog.cn/posts/4ab2.html">https://yafine-blog.cn/posts/4ab2.html</a></p><p>nodejs 使用了某文章师傅提到的<code>nvm</code>，有兴趣的师傅可以了解一下，和<code>jenv</code>差不多效果的东西</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301100318.png"></p><h2 id="图片问题"><a href="#图片问题" class="headerlink" title="图片问题"></a>图片问题</h2><p>解决图片我使用了<code>picgo</code>，可以直接转换成<code>markdown</code>形式的图片</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301112311.png"></p><h2 id="后端评论区通知"><a href="#后端评论区通知" class="headerlink" title="后端评论区通知"></a>后端评论区通知</h2><p>这里试了好些方法，有下面几位师傅的链接</p><p><code>Valine</code> :  <a href="https://blog.csdn.net/weixin_34434736/article/details/113047474">https://blog.csdn.net/weixin_34434736/article/details/113047474</a></p><p>​            <a href="https://blog.lete114.top/article/Valine-LeanCloud-Config.html">https://blog.lete114.top/article/Valine-LeanCloud-Config.html</a></p><p>​    使用这种方法应该不错，但是我又找了找，选择了另外一种方法</p><p><code>Twikoo+腾讯云评论配置</code>：这个我选择了<code>Server酱</code>发送消息</p><p>​    <a href="https://xiaoliblog.cn/page/comments.html#%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B">https://xiaoliblog.cn/page/comments.html#%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B</a></p><p>整体来说比较简单，效果也很好</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301095948.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301100017.png"></p><h2 id="url优化"><a href="#url优化" class="headerlink" title="url优化"></a>url优化</h2><p>一般来说，SEO搜索引擎优化认为，网站的最佳结构是 <strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>Hexo</code>编译的站点结构的<code>URL</code>是：<code>域名/年/月/日/文章标题</code>四层的结构，这样的<code>URL</code>结构很不利于<code>SEO</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章的<code>URL</code></p><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a><strong>方案一</strong>：</h3><p>直接改成<code>域名/文章标题</code>的形式，在<code>Hexo配置文件</code>中修改<code>permalink</code>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://blog.sky03.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><p><strong>这个方式有个不好的地方：</strong></p><p>直接以<code>文章的标题</code>作为URL，而我们所写的文章的标题一般都是中文，但是URL只能用字母数字和标点符号表示，所以中文的URL只能被转义成一堆符号，而且还特别长。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>插件</p><p>插件作用：自动为每篇文章生成一串数字作每篇文章的URI地址。每篇文章的<code>Front-matter</code>中会自动增加一个配置项：<code>abbrlink: xxxxx</code>，该项的值就是当前文章的URI地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-abbrlink config 、固定文章地址插件</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span>  <span class="comment">#算法选项：crc16、crc32，区别见之前的文章，这里默认为crc16丨crc32比crc16复杂一点，长一点</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">dec</span>    <span class="comment">#输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://blog.sky03.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><h2 id="被谷歌和百度收录"><a href="#被谷歌和百度收录" class="headerlink" title="被谷歌和百度收录"></a>被谷歌和百度收录</h2><p>参考文章：<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-25">https://blog.sky03.cn/posts/42790.html#toc-heading-25</a></p><p>谷歌好说，在谷歌网站站长把<code>github page</code>收录进去即可（<a href="https://search.google.com/search-console?%EF%BC%89">https://search.google.com/search-console?）</a></p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301112215.png"></p><p><del>百度的话，(如果没有域名)目前为止好像很麻烦，就不弄了。</del></p><p>好像，，现在可以了？？，和谷歌收录的方法一样。</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220301150646.png"></p><p>那就等第二天过来看吧，，(百度搜索资源平台)</p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><ol><li>自动提交（分三种）<ul><li>主动推送</li><li>自动推送</li><li>sitemap（站点地图）</li></ul></li><li>手动提交<ul><li>即手动地将链接一次性提交给百度</li></ul></li></ol><p>一般自动提交比手动提交效果好一点，自动提交又从效率上来说：</p><p><strong>主动推送&gt;自动推送&gt;sitemap</strong></p><h3 id="自动提交的三种方法"><a href="#自动提交的三种方法" class="headerlink" title="自动提交的三种方法"></a>自动提交的三种方法</h3><ol><li><code>主动推送</code>：最为快速的提交方式。将站点当天新产出链接通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li><code>自动推送</code>：最为便捷的提交方式。将自动推送的JS代码部署在站点的每一个页面源代码中，当部署代码的页面在每次被浏览时，链接就会被自动推送给百度。可以与主动推送配合使用。</li><li><code>sitemap</code>：您可以定期将网站链接放到<code>sitemap文件</code>中，然后将<code>sitemap文件</code>提交给百度。百度会周期性的抓取检查您提交的<code>sitemap</code>，对其中的链接进行处理，但收录速度慢于主动推送。</li></ol><p>这里我选择主动推送，安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>然后打开<code>hexo配置文件</code>，在末尾加入以下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-baidu-url-submit  百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">80</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">blog.sky03.cn</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xxxxxxx</span> <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>再加入新的<code>deploy</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><p>到这里就完成了，，，等待明天的收录审核</p>]]></content>
    
    
    <summary type="html">重新打算开启博客，往上放电有用的东西</summary>
    
    
    
    <category term="奇奇怪怪" scheme="https://h0ld1rs.github.io/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA/"/>
    
    
    <category term="博客搭建" scheme="https://h0ld1rs.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>go渗透测试笔记(二)</title>
    <link href="https://h0ld1rs.github.io/posts/31081.html"/>
    <id>https://h0ld1rs.github.io/posts/31081.html</id>
    <published>2022-02-18T13:37:21.000Z</published>
    <updated>2022-03-01T13:48:33.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go渗透测试笔记-二-—TCP，扫描器和代理"><a href="#Go渗透测试笔记-二-—TCP，扫描器和代理" class="headerlink" title="Go渗透测试笔记(二)—TCP，扫描器和代理"></a>Go渗透测试笔记(二)—TCP，扫描器和代理</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>TCP是面向连接协议的主要标准，也是现代网络的基础。</p><p>作为攻击者，我们应当了解TCP的工作原理，并且能够开发可用的TCP结构体，以便可以识别 打开&#x2F;关闭 的端口，找出错误的结果。</p><p>如误判(syn-flood防护)以及通过端口转发绕过出口限制等等。</p><h2 id="0x01-理解TCP的握手机制"><a href="#0x01-理解TCP的握手机制" class="headerlink" title="0x01 理解TCP的握手机制"></a>0x01 理解TCP的握手机制</h2><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219190005.png"></p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219190050.png"></p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219190247.png"></p><h2 id="0x02-通过端口转发绕过防火墙"><a href="#0x02-通过端口转发绕过防火墙" class="headerlink" title="0x02 通过端口转发绕过防火墙"></a>0x02 通过端口转发绕过防火墙</h2><p>企业组织可以配置防火墙，以防止客户端连接到某些服务器和端口，同时允许访问其他服务器和端口。我们可以使用中间系统代理连接绕过或者穿透防火墙，从而绕过这些限制。</p><blockquote><p>许多企业网络会限制内部资产建立与恶意站点的HTTP连接。假设有一个名为<code>evil.com</code>的恶意网站。如果有员工直接浏览evil.com，则浏览器会阻止，但是，如果员工拥有允许通过防火墙的外部系统，(如 stacktian.com)，则员工可以利用允许的域来反弹与<code>evil.com</code>的连接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219191150.png"></p><p>可以使用端口转发绕过多种限制性网络配置，例如，可以通过跳箱转发流量，以访问网络或者访问绑定到限制性接口的端口</p><h2 id="0x03-编写一个TCP扫描器"><a href="#0x03-编写一个TCP扫描器" class="headerlink" title="0x03 编写一个TCP扫描器"></a>0x03 编写一个TCP扫描器</h2><h4 id="1-测试端口的可用性"><a href="#1-测试端口的可用性" class="headerlink" title="1. 测试端口的可用性"></a>1. 测试端口的可用性</h4><p>创建端口扫描器的第一步是了解如何启动从客户端到服务器组件的相连，在整个示例中，我们需要连接并扫描<code>scanme.nmap.org</code>，为此我们需要使用nmap的包：<code>net.Dial(network,address string)</code></p><p>第一个参数是一个字符串，用于识别标识要启动的连接类型，这是因为<code>Dial</code>不仅适用于TCP，还可以用于创建使用<code>Unix</code>套接字，UDP和第四层协议连接。</p><p>第二个参数需要连接的主机，对于<code>IPV4/TCP</code>连接，字符串使用<code>host:port</code>的形式进行连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;scanme.nmap.org:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;连接成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-执行非并发扫描"><a href="#2-执行非并发扫描" class="headerlink" title="2. 执行非并发扫描"></a>2. 执行非并发扫描</h4><p>一次扫描一个端口没有什么用，TCP的端口为”1–65535”，作为测试，我们这里选择 1024，使用 <code>for</code>循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">1024</span>; i++&#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>,i)</span><br><span class="line">fmt.Println(address)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的就是进行连接，我们还应该加入一些逻辑来关闭连接，这样就不会一直处于一个打开的状态，需要在Conn上调用Close()</p><blockquote><p>Sprintf：用传入的格式化规则符将传入的变量格式化，(终端中不会有显示)</p><p>Printf：用传入的格式化规则符将传入的变量写入到标准输出里面(即在终端中有显示)，</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">79</span>; i&lt;=<span class="number">100</span>; i++&#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>,i)</span><br><span class="line">conn,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//端口已关闭或者过滤</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-执行非并发扫描"><a href="#3-执行非并发扫描" class="headerlink" title="3. 执行非并发扫描"></a>3. 执行非并发扫描</h4><p>上面的例子中我们是进行单个扫描，没有同时扫描，这将浪费很多的时间，于是我们需要使用<code>gorountine</code>提高扫描器的速度，其数量受到系统处理能力和可用内存的限制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>,j)</span><br><span class="line">conn,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//端口已关闭或者过滤</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>,j)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们写出这样的代码的时候，程序几乎是立马就退出了，因为运行的代码会为每一个连接启动一个<code>gorountine,</code>而主<code>gorountine</code>不知道要等待连接发生，代码会在for循环完成之后立刻退出，这可能比端口之间的网络包交换还要快，无法直接获得准确结果。所以我们需要使用<code>sync</code>包中的<code>WaitGroup</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br></pre></td></tr></table></figure><p>创建<code>WaitGroup</code>以后，可以调用一些方法</p><ol><li>Add(int)，他将按所提供的数字递增内部的计算器</li><li>Done() 将计算器减一</li><li>Wait() 会阻止其中调用它的<code>gorountine</code>的执行，并且在内部计算器到达0之前不允许进一步执行。</li></ol><h4 id="4-1-使用WaitGroup进行同步扫描"><a href="#4-1-使用WaitGroup进行同步扫描" class="headerlink" title="4. 1 使用WaitGroup进行同步扫描"></a>4. 1 使用WaitGroup进行同步扫描</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>,j)</span><br><span class="line">conn,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//端口已关闭或者过滤</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d open\n&quot;</span>,j)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此版本中，创建了<code>WaitGroup()</code>用作同步计算器，每次创建<code>gorounine</code>扫描端口的时候，都可以通过<code>wg.Add(1)</code>递增计数器，然后使用<code>Done()递减</code>，在<code>main</code>中调用<code>wg.Wait()</code>将阻塞所有进程直到计数器为0为止</p><h4 id="4-2-工人池–-gt-多通道通信"><a href="#4-2-工人池–-gt-多通道通信" class="headerlink" title="4.2 工人池–&gt;多通道通信"></a>4.2 工人池–&gt;多通道通信</h4><p>为了避免结果不一致，我们需要使用<code>gorountine</code>池管理正在进行的并发工作，使用<code>for</code>循环创建一定数量的工人<code>gorountine</code>作为资源池，然后再<code>main</code>线程中使用通道提供工作</p><p>首先，我们创建一个新程序，程序有100个worker，使用一个<code>int</code>通道将他们打印到屏幕上，继续使用<code>WaitGroup</code>阻塞执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>,wg *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> ports&#123;</span><br><span class="line">fmt.Println(p)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;=<span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ports,&amp;wg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ports &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(ports)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们再使用了make去创建了一个通道，在此处int 值等于 100，这样就可以对该通道进行缓冲，这也意味着 可以在不等待接收器读取数据的情况下，向其发送数据。缓冲通道可以维护多个生产者和消费者的问题，将通道容量设为100意味着发送被阻止之前，可以容纳100个数据项，这样做可以提升性能，因为允许所有的工人立即启动</p><blockquote><p>在上面的例子中，我们可以很清楚的看见，数字并不是按照顺序打印的，因为端口扫描器不回去检查他们的顺序，我们可以使用单独的线程扫描器将扫描结果传回主线程，以便在打印之前对端口进行一个排序，这样做的好处是，可以消除对<code>WaitGroup</code>的依赖</p></blockquote><p>接下来进行修改，使用多通道进行扫描</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports,results <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> ports&#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;scanme.nmap.org:%d&quot;</span>,p)</span><br><span class="line">conn,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">results &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">results &lt;- p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">100</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> openports  [] <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;=<span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ports,results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">ports &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++ &#123;</span><br><span class="line">port := &lt;-results</span><br><span class="line"><span class="keyword">if</span> port != <span class="number">0</span> &#123;</span><br><span class="line">openports = <span class="built_in">append</span>(openports,port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ports)</span><br><span class="line"><span class="built_in">close</span>(results)</span><br><span class="line">sort.Ints(openports)</span><br><span class="line"><span class="keyword">for</span> _,port := <span class="keyword">range</span> openports&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d opend\n&quot;</span>,port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个高效的扫描器需要花时间去处理工人的数量，数量越多，程序执行的越快，但是当工人数量过多的时候，结果就会变得不可靠</p><h3 id="0x04-构造TCP代理"><a href="#0x04-构造TCP代理" class="headerlink" title="0x04 构造TCP代理"></a>0x04 构造TCP代理</h3><h4 id="1-使用io-Reader和io-writer"><a href="#1-使用io-Reader和io-writer" class="headerlink" title="1. 使用io.Reader和io.writer"></a>1. 使用io.Reader和io.writer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writerer <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GO语言中，以上两种数据类型被定义为接口，这意味着他们不能直接被实例化,该抽象方法必须在某种数据类型上得到实现才能运用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  FooReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span>  FooWriter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolreader * FooReader)</span></span> Read(p [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//从某处读取一些数据</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;ssssss&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s),<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolWriter * FooWriter)</span></span> Write(p [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//从某处写入一些数据</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;ssssss&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s),<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面看个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从标准输入 stdin 读取数据 io.Reader</span></span><br><span class="line"><span class="keyword">type</span>  FooReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">//定义一个 写入标准输出 stdout的 io.Writer</span></span><br><span class="line"><span class="keyword">type</span>  FooWriter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolReader * FooReader)</span></span> Read(b [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;in &gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> os.Stdin.Read(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolWriter * FooWriter)</span></span> Write(b [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;out &gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//实例化 Reader和writer</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">reader FooReader</span><br><span class="line">writer FooWriter</span><br><span class="line">)</span><br><span class="line"><span class="comment">//创建缓冲区已保存输入/输出</span></span><br><span class="line">input := <span class="built_in">make</span>([] <span class="type">byte</span>,<span class="number">4096</span>)</span><br><span class="line"><span class="comment">//使用 reader读取</span></span><br><span class="line">s,err := reader.Read(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;unable to read data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Read %d bytes from stdin\n&quot;</span>,s)</span><br><span class="line"><span class="comment">//使用writer写出</span></span><br><span class="line">s,err = writer.Write(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes to stdout\n&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将Reader 复制到Writer是一种非常常见的模式，于是官方提供了一个<code>io.Copy()</code>用于简化操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从标准输入 stdin 读取数据 io.Reader</span></span><br><span class="line"><span class="keyword">type</span>  FooReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">//定义一个 写入标准输出 stdout的 io.Writer</span></span><br><span class="line"><span class="keyword">type</span>  FooWriter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolReader * FooReader)</span></span> Read(b [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;in &gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> os.Stdin.Read(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foolWriter * FooWriter)</span></span> Write(b [] <span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;out &gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> os.Stdout.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//实例化 Reader和writer</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">reader FooReader</span><br><span class="line">writer FooWriter</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(&amp;writer, &amp;reader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;发生了错误&quot;</span> )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了io.Copy 只需要 处理先读后写的过程，而无需关注其他细节。</p><h4 id="2-创建回显服务器"><a href="#2-创建回显服务器" class="headerlink" title="2. 创建回显服务器"></a>2. 创建回显服务器</h4><p>按照大多数语言的习惯，首先需要一个回显服务器，以学习如何再套接字中读写数据，为此，需要用到<code>net.Conn</code></p><p>创建Conn实例以后，可以通过TCP套接字接受和发送数据，不过TCP服务器不能简单的创造一个连接，连接必须由客户端发起建立。</p><p>在Go中可以使用<code>net.Listen(network,address string)</code>在特定端口打开TCP监听器，客户端连接后，可以使用<code>Accept()</code>创建一个Conn对象，可以用于接受和发送数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//创建一个缓冲区来接受储存的数据</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">512</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;<span class="comment">//进行无线循环</span></span><br><span class="line"><span class="comment">//通过conn.Read接受数据到缓冲区</span></span><br><span class="line">size,err := conn.Read(b[<span class="number">0</span>:])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Client disconnected&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Unexpected error&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Received %d bytes : %s\n&quot;</span>,size,<span class="type">string</span>(b))</span><br><span class="line"><span class="comment">//通过write 发送数据</span></span><br><span class="line">log.Println(<span class="string">&quot;Writing Data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> _,err :=conn.Write(b[<span class="number">0</span>:size]);err !=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//在所有接口上绑定 TCP端口 20080</span></span><br><span class="line">listener,err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to bind to tcp&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Listening on 0.0.0.0:20080&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//等待连接，在已经建立连接上创捷 net.Conn</span></span><br><span class="line">conn,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to accept connection&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理连接，使用gorountine并发</span></span><br><span class="line"><span class="keyword">go</span> echo(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中Conn既是<code>Reader</code>也是<code>Writer</code>，实现了<code>Read[]byte</code>，和Write([] byte)方法</p><p>之后，使用<code>gorountine</code>使其成为并发调用，以便在等待处理函数完成时，其他连接不会被阻塞</p><p>当我们使用<code>telnet</code>进行一个连接的时候</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220220114739.png"></p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220220114831.png"></p><p>可以看见回显服务器将客户端发送给它的内容完全重复的发送给客户端</p><h4 id="3-创建缓冲带的监听器来改进代码"><a href="#3-创建缓冲带的监听器来改进代码" class="headerlink" title="3. 创建缓冲带的监听器来改进代码"></a>3. 创建缓冲带的监听器来改进代码</h4><p>上面的例子依赖相当低级的函数调用，且缓冲区跟踪重复读写，其运行过程容易出错。可以使用<code>bufio</code>包，其中也包含了<code>Reader</code>和<code>Writer</code>，我们稍微改进一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo2</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//创建一个缓冲区来接受储存的数据</span></span><br><span class="line">reader :=bufio.NewReader(conn)</span><br><span class="line">s,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to read data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Read %d bytes :%s&quot;</span>,<span class="built_in">len</span>(s),s)</span><br><span class="line">log.Println(<span class="string">&quot;Writing data&quot;</span>)</span><br><span class="line">writer := bufio.NewWriter(conn)</span><br><span class="line"><span class="keyword">if</span> _, err := writer.WriteString(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to write data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">writer.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//在所有接口上绑定 TCP端口 20080</span></span><br><span class="line">listener,err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to bind to tcp&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Listening on 0.0.0.0:20080&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//等待连接，在已经建立连接上创捷 net.Conn</span></span><br><span class="line">conn,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to accept connection&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理连接，使用gorountine并发</span></span><br><span class="line"><span class="keyword">go</span> echo2(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们不在<code>Conn</code>上调用函数<code>Read([]byte)</code> 和<code>Write([]byte)</code>，而是通过NewReader(io.Reader)和 NewWriter(io.Writer)初始化新的缓冲带。这些调用都以现有的<code>Reader</code>和<code>Writer</code>为基础</p><p>两个缓冲实例都具有用于读取和写入的字符串数据的功能。<code>ReadString(byte)</code>带有一个分隔符，表示数据读取长度。而WritrString(byte)则将字符串写入套接字，写入数据时，需要显示调用<code>writer.Flush()</code>，以便将所有的数据写入底层的<code>Writer</code></p><p>在此示例中，变量conn作为源和目标传递，因为将在建立的连接上回显内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func echo3(conn net.Conn)  &#123;</span><br><span class="line">defer conn.Close()</span><br><span class="line">//使用io.Copy进行复制</span><br><span class="line">if _,err := io.Copy(conn,conn); err != nil &#123;</span><br><span class="line">log.Fatalln(&quot;unable to read/write data&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-创建一个TCP客户端"><a href="#4-创建一个TCP客户端" class="headerlink" title="4. 创建一个TCP客户端"></a>4. 创建一个TCP客户端</h4><p>在很多情况下，我们需要把一个网站上收到的流量全部转发到另一台服务器，我们可以编写如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(src net.Conn)</span></span>&#123;</span><br><span class="line">dst,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;某A网站&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to connect to our unreachable host&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line"><span class="comment">//在gorountine 中运行防止 io.Copy被阻塞</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//将资源的输出复制到目标</span></span><br><span class="line"><span class="keyword">if</span> _,err := io.Copy(dst,src);err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//将目标的输出复制回源</span></span><br><span class="line"><span class="keyword">if</span> _,err := io.Copy(src,dst); err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//在本地的80端口上监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to bind to port&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn ,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to accept connection&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们把需要转发的网站标记为A，执行脚本的网站标记为B，以便理解下面的思路</p><p>其中，我们调用了两次Copy函数，第一次是确保A网站能和B服务器进行连接，第二次是确保回显的数据被写回到连接客户端的连接中。</p><p>这样，在代理的端口，就能持续接收到他发送的数据</p><h4 id="5-复现Netcat命令"><a href="#5-复现Netcat命令" class="headerlink" title="5. 复现Netcat命令"></a>5. 复现Netcat命令</h4><p>这里用到了Go的包<code>os/exec</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>)</span><br></pre></td></tr></table></figure><p>这将创建Cmd的实例，但尚未执行该命令，可以使用<code>stdin</code>和<code>stdout</code>，或者<code>Copy</code>将Reader或者<code>Writer</code>赋值给<code>Cmd</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd.Stdin= conn</span><br><span class="line">cmd.stdout = conn</span><br></pre></td></tr></table></figure><p>处理完数据流以后，就可以使用<code>cmd.Run()</code>运行命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := cmd.Run();err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上操作很适合在linux下运行，但是在<code>Windows</code>系统上运行程序时，使用<code>cmd.exe</code>而不适用<code>/bin/bash</code>，你就会发现，由于某些Windows特定的匿名管道处理，连接的客户端永远收不到命令输出。</p><p>要解决上面的问题，有两种方案</p><p>首先，可以通过代码显示强制刷新标准输出以事应此席位的差别，不再直接将Conn赋给 cmd.Stdout，而是实现一个包装<code>bufio.Writer</code>(缓冲区写入器)的自定义<code>Writer</code>，并且显示调用<code>Flush</code>方法以强制刷新缓冲区</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Flusher包装 bufio.Writer,显示刷新所有写入</span></span><br><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">struct</span> &#123;</span><br><span class="line">w * bufio.Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewFlusher 从 io.Writer 创建一个新的 Flusher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFlusher</span><span class="params">(w io.Writer)</span></span> * Flusher&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Flusher&#123;</span><br><span class="line">w : bufio.NewWriter(w),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入数据并且显示刷新缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo *Flusher)</span></span> Write(b []<span class="type">byte</span>)(<span class="type">int</span>,<span class="type">error</span>) &#123;</span><br><span class="line">count,err := foo.w.Write(b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := foo.w.Flush();err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle1</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="comment">//显示调用 /bin/sh 并且使用 -i进入交互模式</span></span><br><span class="line"><span class="comment">//这样我们就可以用它作为标准输入和输出</span></span><br><span class="line"><span class="comment">//对于Linux 使用 exec.Command(&quot;/bin/sh&quot;,&quot;-i&quot;)</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;cmd.exe&quot;</span>)</span><br><span class="line"><span class="comment">//将标准输入设置为我们的连接</span></span><br><span class="line">cmd.Stdin = conn</span><br><span class="line"><span class="comment">//从连接创建一个Flusher用于标准输出</span></span><br><span class="line"><span class="comment">//这样可以确保标准输出被充分刷新并且通过 net.Conn进行发送</span></span><br><span class="line">cmd.Stdout = NewFlusher(conn)</span><br><span class="line"><span class="comment">//运行命令</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//在本地的80端口上监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:80&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to bind to port&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn ,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalln(<span class="string">&quot;unable to accept connection&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle1(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我这里踩了一个坑 <code>cmd /c</code>，在写脚本的时候，不可以加入 ‘&#x2F;c’参数，否则回一直无法建立连接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220221183903.png"></p><p>当然，使用<code>telnet</code>也可以，效果是一样的</p><p>另一种方式是使用 <code>io.Pipe()</code>，该函数是<code>go</code>的同步内存管道，可用于连接<code>Reader</code>和<code>Writer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> (*PipeReader, *PipeWriter) &#123;</span><br><span class="line">p := &amp;pipe&#123;</span><br><span class="line">wrCh: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">byte</span>),</span><br><span class="line">rdCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PipeReader&#123;p&#125;, &amp;PipeWriter&#123;p&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据其定义，我们可以对上面的代码进行一个优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle2</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmd := exec.Command(&quot;/bin/sh&quot;,&quot;-i&quot;)</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;cmd.exe&quot;</span>)</span><br><span class="line">rp, wp := io.Pipe()</span><br><span class="line"><span class="comment">//将标准输入设为我们的连接</span></span><br><span class="line">cmd.Stdin = conn</span><br><span class="line">cmd.Stdout = wp</span><br><span class="line"><span class="keyword">go</span> io.Copy(conn, rp)</span><br><span class="line">cmd.Run()</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:20080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handle2(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用<code>io.Pipe</code>的时候，对创建一个同步连接的一个<code>reader</code>和一个<code>writer</code>，任何被写入<code>writer</code>的数据(wp)，都会被<code>reader</code>(rp)读取，因此，我们需要将<code>writer</code>分配给<code>cmd.Stdout</code>，然后使用<code>io.Copy(conn,rp)</code> 将<code>PipeReader</code>链接到<code>TCP</code>连接。之后使用<code>gprountine</code>防止阻塞。命令的标准输入发送到<code>writer</code>，然后通过管道传送到<code>reader</code>，并通过<code>TCP</code>连接输出。</p>]]></content>
    
    
    <summary type="html">对Go渗透测试中Tcp和扫描器的学习</summary>
    
    
    
    <category term="Go渗透测试" scheme="https://h0ld1rs.github.io/categories/Go%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Golang,渗透测试" scheme="https://h0ld1rs.github.io/tags/Golang-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Go渗透测试笔记(一)</title>
    <link href="https://h0ld1rs.github.io/posts/61606.html"/>
    <id>https://h0ld1rs.github.io/posts/61606.html</id>
    <published>2022-02-14T13:34:41.000Z</published>
    <updated>2022-03-01T13:48:19.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GO渗透测试笔记-一）"><a href="#GO渗透测试笔记-一）" class="headerlink" title="GO渗透测试笔记(一）"></a>GO渗透测试笔记(一）</h1><h1 id="0X01-基本使用"><a href="#0X01-基本使用" class="headerlink" title="0X01 基本使用"></a>0X01 基本使用</h1><ol><li><p>当在某些极端的情况可以使用<code>go build -ldflags &quot;-w -s&quot;</code>进行编译，从二进制文件中剥离调试信息和字符表，从而减少文件的大小，适合在某些极端的情况进行嵌入（大约可以减少 30%）</p></li><li><p>创建使用不同架构上使用的二进制文件—<strong>交叉编译</strong></p></li><li><p>go doc 函数 –&gt;可以查询有关的包，函数的使用方法文档</p></li><li><p>go get —-&gt;  很多情况下，go程序需要要引入第三方包，可以使用此命令进行导入</p><blockquote><p>即使你使用了 import 导入了相应的包，如<code>stacktian/ldapauth</code>，也无法访问。必须先下载实际的包，</p><p>go get “github.com&#x2F;stacktian&#x2F;ldapauth” 下载实际的包，并且放在 $GOPATH&#x2F;SRC目录下</p></blockquote></li><li><p>go 引入了两个工具<code>dep和mod</code>来锁定清理依赖项，有助于避免正在进行的依赖项不一致</p><blockquote><p>go mod tidy</p><p>go mod download 是使用mod时经常使用的两个命令</p></blockquote></li><li><p>go fmt –&gt;可以自动格式化源代码，强制使用正确的换行符，缩进和大括号来设置代码样式。—&gt;大部分IDE包含的钩子会在保存文件时自动执行 go fmt，因此无需显式执行该命令</p></li><li><p>golint 和 go vet命令</p><blockquote><p>go fmt 会更改代码的语法样式，但是golint会报告样式错误，例如缺少注释，不遵循约定的变量命名等，无用的类型等等。</p><p>golint时独立工具，需要 go get -u “golang.org&#x2F;x&#x2F;lint&#x2F;golint”进行下载</p><p>go vet 也会尝试确定编译器中可能忽略的问题，其中一些可能是合法的错误</p></blockquote></li><li><p>GO Playground -&gt; 托管的执行环境，为开发人员提供了稳定的web前端，以快速，测试，执行和共享Go代码段，但是会限制使用系统命令和第三方交互</p></li></ol><h2 id="go-的基本语法"><a href="#go-的基本语法" class="headerlink" title="go 的基本语法"></a>go 的基本语法</h2><h4 id="1-结构体和接口"><a href="#1-结构体和接口" class="headerlink" title="1. 结构体和接口"></a>1. 结构体和接口</h4><p>定义如下方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p * Person)</span></span> sayHello()  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> guy = <span class="built_in">new</span>(Person)</span><br><span class="line">guy.Name = <span class="string">&quot;Dave&quot;</span></span><br><span class="line">guy.Age = <span class="number">12</span></span><br><span class="line">guy.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此语言定义Person变量的方法，sayHello()，其他语言将p视为<code>self</code>与<code>this</code>的引用。</p><blockquote><p>于此同时，结构体缺少作用域修饰符(如 public ，private 等等)，</p><p>Go语言中通过大写字母确定作用域，以大写字母开头的类型和字段可以在包外部进行导出并访问，以小写字母开头的类型和字段是私有的，只能在包内部访问</p></blockquote><p>引入接口时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p * Person)</span></span> sayHello()  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  Friend <span class="keyword">interface</span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(f Friend)</span></span>  &#123;</span><br><span class="line">f.sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> guy = <span class="built_in">new</span>(Person)</span><br><span class="line">guy.Name = <span class="string">&quot;Dave&quot;</span></span><br><span class="line">Greet(guy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了名为<code>friend</code>的接口，该接口需要实现一个方法<code>sayHello</code>，这意味着任何实现了方法<code>sayHello()</code>类型的都是<code>Friend</code>，</p><blockquote><p>注意：Friend实际上并未实现这个函数，他只是说，如果你是Friend，则能够使用<code>sayHello</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> sayHello() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;woof,woof&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p * Person)</span></span> sayHello()  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  Friend <span class="keyword">interface</span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(f Friend)</span></span>  &#123;</span><br><span class="line">f.sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> guy = <span class="built_in">new</span>(Person)</span><br><span class="line">guy.Name = <span class="string">&quot;Dave&quot;</span></span><br><span class="line">Greet(guy)</span><br><span class="line"><span class="keyword">var</span> dog = <span class="built_in">new</span> (Dog)</span><br><span class="line">Greet(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-控制结构"><a href="#2-控制结构" class="headerlink" title="2 控制结构"></a>2 控制结构</h4><p>Go 包含的控制结构比其他现代语言要少的多。Go主要的语法条件是<code>if/else</code></p><p>用户输入的时候用<code>fmt.Scanln()</code>比较合适</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;请输入x&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;x)</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;x is equals 1&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;x is not equals 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当使用switch结构的时候，Go语言必须使用花括号,与其他现代编程语言不同的是，go不需要包含<code>break</code>语句。在其他语言中当 case不包含<code>break</code>的时候，将持续执行，在<code>go</code>中只会执行一种语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> x = <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;foo&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;fonud foo&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;bar&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;fonud bar&quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Go有一个 <code>type switch</code>的特殊变体，通过<code>switch</code>语句进行类型断言，对判断类型接口很有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"><span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">foo(<span class="type">int</span>(<span class="number">64</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>本示例中使用特殊语法(i.type)检查 i 变量的类型，然后进行匹配</p></blockquote><p>最后一个流程控制是<code>for</code>循环，for循环是 Go用于执行重复代码的结构，Go没有诸如<code>do</code>或者<code>while</code>之类的约定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是 for循环的一个轻量级变体，用于遍历集合或者切片&#x2F;映射</p><blockquote><p>和python 一样，idx用于索引</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums :=[]<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx,val := <span class="keyword">range</span> nums&#123;</span><br><span class="line">fmt.Println(idx+<span class="number">1</span>,val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-并发"><a href="#3-并发" class="headerlink" title="3. 并发"></a>3. 并发</h4><p>go拥有比其他语言更为简单的并发模型，可以使用<code>gorountine</code>并发执行代码，因其是可以同时运行的函数或者方法，<code>gorountine</code>被称为轻量级线程，于实际线程相比，创建他们的成本极低</p><p>可以通过在被调用的方法或者函数之前使用<code>go</code>关键字创建<code>gorountine</code>实现并发</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f function&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219124257.png"></p><p>在函数之前使用了<code>go</code>关键字，这将意味着程序同时运行f()和main()，换句话说：main()函数的执行将继续，而无需等待f()完成。当我们使用<code>time.Sleep</code>强制main函数暂停，以便f()可以执行完，如果不暂停main()函数，则该线程很可能在f()执行完毕之前就退出，将看不到其结果。</p><p>go 具有一种称为<code>通道</code>（channel）的数据类型，该数据类型提供了一个机制，通过该机制，<code>gorountine</code>可以同步执行函数并且这些函数可以互相通信。下面的例子显示使用一个通道时显示不用字符串的长度及其总和的示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strlen</span><span class="params">(s <span class="type">string</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">c &lt;- <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> strlen(<span class="string">&quot;Salutations&quot;</span>,c)</span><br><span class="line"><span class="keyword">go</span> strlen(<span class="string">&quot;wolrd&quot;</span>,c)</span><br><span class="line">x,y := &lt;-c,&lt;-c</span><br><span class="line">fmt.Println(x,y,x+y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，定义并使用<code> chan int</code>类型的变量 c，你可以定义各种类型的通道，具体取决于通道传递的数据类型，你可以在<code>gorountine中</code>定义各种类型的通道，具体取决于要在通道传递的数据类型，上面的类型是要传递<code>int</code>类型的数据传长度。因此使用<code>int</code>类型的传递参数</p><p>请注意一个新的运算符，<code>&lt;-</code>。该运算符只是数据时流入还是流出通道，你可以这样理解他，”将物品放在桶里或者取出一个物品”</p><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220219130532.png"></p><p>结果是<code>5,6,11</code>，可以理解为是一个栈，将最先放进去放到最底部，取出最后放入的，所以才会出现这种情况。</p><p>同时，从通道中取出数据则表明要取出足够的数据，否则会阻塞在这一行</p><h4 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4. 错误处理"></a>4. 错误处理</h4><p>与大多数现代编程语言不同，Go 没有<code>try/catch/finally</code>错误的处理语法。但是，它使用了一种更为简单的方法，鼓励你多去检查哪些容易出现错误的地方，这样他们就不会聚焦在调用链中。</p><p>Go使用以下接口声明定义内置错误的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着可以实现了方法Error()的任何数据类型，该方法返回字符串作为一个错误，例如，可以在代码中自定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e myError)</span></span>Error() <span class="type">string</span>  &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> <span class="type">error</span>  &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;some Error Occurred&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> err := foo(); err !=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="comment">//处理错误的回显</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现函数和方法至少返回一个值是很普遍的，并且这些值中总会又一个返回值是错误的，在Go中如果返回错误值是<code>nil</code>,则表明函数未出现任何问题。</p><blockquote><p>go 语言中没有形成统一的错误记录方法，原因之一是，与其他语言不同，Go的内置错误类型没有隐式包含堆栈跟踪以帮助查明错误的上下文或者位置，</p></blockquote><h4 id="5-处理结构化数据"><a href="#5-处理结构化数据" class="headerlink" title="5. 处理结构化数据"></a>5. 处理结构化数据</h4><p>安全从业人员会预先编好处理结构挂数据或者具有通用编码的数据，如<code>JSON</code>,<code>xml</code></p><p>最常见的两个包是<code>encoding/xml</code>和<code>encoding.json</code>，这两个包都可以组编和结组任意数据结构，这意味着他们可以将字符串转化为结构体，也可以将结构体序列化为字节切片，然后将字节切片反序列化为结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo02 <span class="keyword">struct</span> &#123;</span><br><span class="line">Bar <span class="type">string</span></span><br><span class="line">Baz <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := Foo02&#123;<span class="string">&quot;h0ld1rs&quot;</span>,<span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">b,_ := json.Marshal(f)</span><br><span class="line">fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json.Marshal 将struct 编码为<code>JSON</code>，返回一个字节切片，随后将其打印到标准输出，显示的是Json形式的字节码形式</p><p>json.Unmarshal(b,&amp;f)  将其进行解码，生成一个foo结构体实例。处理xml与此过程大致相同</p><p><a href="https://www.jianshu.com/p/da486be83e8a">https://www.jianshu.com/p/da486be83e8a</a></p>]]></content>
    
    
    <summary type="html">正在学习golang语言的一些笔记</summary>
    
    
    
    <category term="Go渗透测试" scheme="https://h0ld1rs.github.io/categories/Go%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Golang,渗透测试" scheme="https://h0ld1rs.github.io/tags/Golang-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
